# 2 aturan yang harus kita perhatikan agar tercipta pengalaman pengguna yang baik ketika menerapkan proses komputasi intensif yang memakan waktu
    - jangan memblok ui thread atau main thread
    - jangan melakukan pemanggilaan komponen ui widget di dalam background thread atau thread yang sedang berjalan secara asynchronous
        Android UI toolkit hanya berjalan pada ui thread atau main thread


# Thread
    ``` kotlin
    fun onClick(v: View) {
        Thread(Runnable {
            val txt = loadStringFromNetwork("http://example.com/string.json")
            textView.setText(txt)   // melanggar aturan no 2
        }).start()
    }
    ```

    fungsi yang dapat dimanfaatkan untuk memenuhi aturan 2:
        - Activity.runOnUiThread(Runnable)
        - View.post(Runnable)
        - View.postDelayed(Runnable, long)

    ``` kotlin
    fun onClick(v: View) {
        Thread(Runnable {
            val txt = loadStringFromNetwork("http://example.com/string.json")
            textView.post(Runnable() {
                textView.setText(txt)
            })
        }).start()
    }
    ```


# Handler
    handler dapat mengirim dan memproses message dan object runnable lainnya yang berhubungan dengan thread
    ketika handler diciptakan, maka dia terkait dengan thread di mana diciptakan



# Executor
    komponen pada Android yang memiliki kemampuan untuk memanajemen banyak thread sekaligus

    untuk emngatur jumlah thread yang dibuat:
        - newSingleThreadExecutor
        - newFixedThreadPool(nThreads)
        - newCachedThreadPool

    selain Executor ada juga ExecutorService: bisa memantau proses yang berjalan dengan menggunakan fungsi submit() yang menghasilkan Future.
        shutdown
        cancel


# Coroutine
    ``` (build.gradle)
        implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1"
        implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1"
    ```

    2 cara launch coroutine
        - launch (tanpa nilai kembalian)
        - async (dengan kembalikan)

    Dispatcher
        - Dispatcher.Default
        - Dispatcher.IO
        - Dispatcher.Main

    scope yang membentuk structured concurrency. beberapa scope yang bisa dipakai di Android
        - CoroutineScope        can be cancel() ed
        - LifecycleScope        scope khusus di dalam Activity atau Fragment, coroutine mati saat onDestroy()
        - ViewModelScope        scope yang digunakan di ViewModel, coroutine mati saat onCleared()


# links
    https://developer.android.com/guide/components/processes-and-threads.html
    http://android-developers.blogspot.co.id/2009/05/painless-threading.html
    https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html
    https://www.lukaslechner.com/understanding-kotlin-coroutines-with-this-mental-model/

