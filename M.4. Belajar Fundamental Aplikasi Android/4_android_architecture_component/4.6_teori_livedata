# what
    LiveData adalah observable class holder yang akan memberikan pemberitahuan ketika terjadi perubahan data
    LiveData bersifat Lifecycle-Aware
    LiveData hanya akan memperbarui komponen pengamat atau observers ketika Lifecycle aplikasi dalam keadaan aktif
    LiveData adalah pembungkus yang dapat digunakan untuk membungkus data apapun, termasuk object yang mengimplementasikan Collection
    LiveData biasanya disimpan dalam object ViewModel


# keuntungan menggunakan LiveData
    - UI akan selalu mendapatkan data akurat, karena selalu memberikan pemberitahuan jika ada perubahan
    - tidak akan terjadi memory leak yang membuat aplikasi berat bahkan bisa crash
    - aplikasi tidak akan crash jika kita keluar/stop Activity
    - tidak ada lagi perubahan UI secara manual berkaitan dengan update data, karena data baru akan selalu dikirim secara otomatis
    - LiveData akan selalu memperbarui data. jika lifecycle tidak aktif, ia menerima data terbaru setelah menjadi aktif kembali
    - mampu mempertahankan data ketika terjadi perubahan konfigurasi. jika suatu Acivity atau Fragment dibentuk kembali karena perubahan konfigurasi, seperti rotasi perangkat, ia akan segera menerima data terbaru yang tersedia
    - berbagi sumber data. anda dapat memperluas object LiveData menggunakan Singleton Pattern untuk membungkus layanan service sehingga dapat dibagikan


# implementasi LiveData
    1. buat LiveData untuk menampung tipe data tertentu. ini biasanya dilakukan di dalam kelas ViewModel
    2. buat object Observer yang mendefinisikan metode onChanged(), yang mana ketika terjadi perubahan maka akan mengontrol apa yang terjadi pada data yang disimpan object LiveData. anda biasanya membuat object Observer di UI controller, seperti Activity atau Fragment
    3. lampirkan object Observer ke object LiveData menggunakan metode observe(). Metode observe() akan mengambil object LifecycleOwner sebagai object Observer dari object LiveData sehingga akan ada pemberitahuan tentang perubahan. anda biasanya melampirkan object observer di UI controller, seperti Activity dan Fragment

    ketika anda memperbarui nilai yang disimpan dalam object LiveData, ini akan memicu semua subscriber yang terdaftar dalam keadaan aktif.


# membuat object LiveData
    dalam object ViewModel:

    ```
        class MyViewModel : ViewModel() {
            private lateinit var name: MutableLiveData<String>

            fun getName(): LiveData<String> {
                name = MutableLiveData()
                return name
            }
        }
    ```

    ## melakukan observe object LiveData
        dalam kebanyakan kasus, komponen aplikasi seperti metode onCreate() adalah tempat yang tepat untuk memulai proses observer object LiveData
        why?
            - untuk memastikan sistem tidak melakukan panggilan berulang atau panggilan yang tidak perlu dilakukan dari suatu Activity atau metode onResume() pada Fragment
            - LiveData juga berfungsi untuk memastikan apakah ada perubahan data yang bisa segera ditampilkan dalam Activity atau Fragment

        ```kotlin
            class MainActivity : AppCompatActivity() {

                private lateinit var viewModel: MyViewModel

                override fun onCreate(savedInstanceState: Bundle?) {
                    super.onCreate(savedInstanceState)
                    // Other code to setup the activity...

                    // Get the ViewModel.
                    viewModel = ViewModelProvider(this)[MyViewModel::class.java]

                    // Create the observer which updates the UI.
                    val nameObserver: Observer<String> = Observer { newName ->
                        // Update the UI, in this case, a TextView.
                        nameTextView.setText(newName)
                    }

                    // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
                    viewModel.getName().observe(this, nameObserver)
                }
            }
        ```


# LiveData vs MutableLiveData
    LiveData tidak memiliki akses untuk memperbarui data yang disimpan
    MutableLiveData memiliki akses untuk mengubah data


# perbarui object LiveData
    kelas MutableLiveData memiliki 2 metode yang bisa digunakan untuk mengedit nilai yang disimpan LiveData
        - setValue() dipakai saat main thread
        - postValue() dipakai saat di background thread


    ## transformations
        gunakan method transformations untuk membawa informasi melewati observer lifecycle
        transformations dihitung lazily

        - Transformations.map
            fungsi yang akan dieksekusi pada main thread

            ```kotlin
                val userLiveData: LiveData<String> = ...;
                valuserName = Transformations.map(userLiveData, user -> {
                      return user.firstName + " " + user.lastName
                });
            ```

        - Transformations.switchMap
            mirip map, bedanya perubahan dari sebuh LiveData yang diamati akan memicu pemanggilan LiveData lain
            ```kotlin
                private fun getUser(id: String): LiveData<User> {
                  ...
                }
                val userId: LiveData<String> = ...
                val user = Transformations.switchMap(userId) { id -> getUser(id) }
            ```


# links
    [https://developer.android.com/topic/libraries/architecture/livedata]
    [https://codelabs.developers.google.com/codelabs/android-lifecycles/#0]

    [https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150]
    [https://proandroiddev.com/android-singleliveevent-redux-with-kotlin-flow-b755c70bb055]
